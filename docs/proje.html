<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>TÜRKİYE İKİNCİ EL ARAÇ İLANLARI ÜZERİNE VERİ ANALİZİ – R-U-OK ? Takımı Analitik Labı</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-9e883780f2fbd657c48aa509da551084.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-e77499559b757ffca09e2ecb2797a99c.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style> .navbar .navbar-brand { color: #e74c3c !important; /* Renk özelleştirmesi */ font-weight: bold; } </style>


<link rel="stylesheet" href="styles.css">
</head>

<body class="docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">R-U-OK ? Takımı Analitik Labı</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Ana Sayfa</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./takim.html"> 
<span class="menu-text">Takım Üyeleri</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./portfolyo.html"> 
<span class="menu-text">Porfolyo</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./proje.html" aria-current="page"> 
<span class="menu-text">Proje</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#proje-sayfamıza-hoş-geldiniz." id="toc-proje-sayfamıza-hoş-geldiniz." class="nav-link active" data-scroll-target="#proje-sayfamıza-hoş-geldiniz."><span class="header-section-number">1</span> <strong>Proje sayfamıza hoş geldiniz.</strong></a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TÜRKİYE İKİNCİ EL ARAÇ İLANLARI ÜZERİNE VERİ ANALİZİ</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="proje-sayfamıza-hoş-geldiniz." class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <strong>Proje sayfamıza hoş geldiniz.</strong></h1>
<p><em>Projemizle ilgili güncellemelerden haberdar olmak için bu alanı takip edin.</em></p>
<p><strong>Proje Genel Bakış ve Kapsamı</strong></p>
<p>Bu çalışma, 2025 yılı Türkiye ikinci el otomobil pazarı verilerini kullanarak marka ve şehir bazlı benchmark analizi, kapsamlı keşifsel veri analizi (EDA) ve fiyat tahminlemesi (forecasting) gerçekleştirmeyi amaçlamaktadır. Kod, anlatı ve görseller Quarto ile tekrar üretilebilir biçimde hazırlanmıştır.</p>
<p><strong>Veri</strong></p>
<p>Bu proje kapsamında analiz edilen veri seti, 2025 yılında Türkiye’deki ikinci el otomobil ilanlarından derlenmiştir. Veriler çevrimiçi bir otomobil satış platformundan (sahibinden.com) 2025 yılı başlarında web kazıma (web scraping) yoluyla elde edilmiştir. Bahri Doğru (2025) tarafından Kaggle üzerinde paylaşılan bu ham veri seti, Türkiye genelinde <strong>6675 adet</strong> ikinci el araç ilanına ait bilgileri içermektedir. Her bir satır bir araç ilanını temsil etmekte ve araçların teknik özelliklerinden satıcı bilgilerine kadar çeşitli değişkenler barındırmaktadır.</p>
<p><strong>Değişkenler:</strong> Veri setinde toplam 29 sütun (değişken) bulunmaktadır. Önemli değişkenler ve açıklamaları aşağıda verilmiştir:</p>
<ul>
<li><p><strong>İlan Başlığı (ListingTitle):</strong> Araç ilanının başlığı (genellikle marka, model ve bazı özellikleri içerir).</p></li>
<li><p><strong>Konum (District, City):</strong> İl ve ilçe/mahalle bazında aracın bulunduğu konum. “City” il (örn. İstanbul, Ankara) ve “District” daha spesifik konum bilgisini içerir.</p></li>
<li><p><strong>Fiyat (Price(TRY) / Price_Clean):</strong> İlan fiyatı (Türk Lirası cinsinden). <code>Price(TRY)</code> metin olarak TL simgesiyle verilirken, <code>Price_Clean</code> sayısal olarak fiyat bilgisini içerir.</p></li>
<li><p><strong>Marka (Brand), Seri (Series), Model:</strong> Aracın markası (örn. <strong>Renault</strong>, <strong>BMW</strong>), model serisi ve tam model adı</p></li>
<li><p><strong>Model Yılı (Year / Year_Clean):</strong> Aracın üretim yılı. (Örn. 2015)</p></li>
<li><p><strong>Kilometre (Mileage(km) / Mileage_Clean):</strong> Aracın kullanılmış kilometre bilgisi. <code>Mileage_Clean</code> sayısal değeri kilometre cinsinden verir.</p></li>
<li><p><strong>Vites Tipi (TransmissionType):</strong> Şanzıman türü (Manuel, Otomatik veya Yarı-Otomatik).</p></li>
<li><p><strong>Yakıt Türü (FuelType):</strong> Yakıt tipi (Benzin, Dizel, LPG &amp; Benzin, Hibrit, Elektrik).</p></li>
<li><p><strong>Kasa Tipi (BodyType):</strong> Araç gövde tipi (Sedan, Hatchback, SUV, vb.).</p></li>
<li><p><strong>Renk (Color):</strong> Aracın rengi (örn. Beyaz, Siyah).</p></li>
<li><p><strong>Motor Hacmi (EngineSize(cc) / EngineSize_Clean):</strong> Motor silindir hacmi (cc – santimetreküp cinsinden). Örneğin 1598 cc.</p></li>
<li><p><strong>Motor Gücü (EnginePower(HP) / EnginePower_Clean):</strong> Motor gücü (beygir gücü – HP).</p></li>
<li><p><strong>Çekiş Tipi (DriveTrain):</strong> Çekiş türü (Önden çekiş – FWD, Arkadan itiş – RWD, Dört çeker – 4WD/AWD).</p></li>
<li><p><strong>Boya/Parça Durumu (PaintAndPartsCondition):</strong> Araçta boyalı, değişmiş parça olup olmadığı bilgisi (orijinal, lokal boya, değişen parça gibi ayrıntılar).</p></li>
<li><p><strong>Takasa Uygunluk (TradeInAvailable):</strong> İlan sahibinin takas (başka araçla değişim) kabul edip etmediği.</p></li>
<li><p><strong>Satıcı Türü (SellerType):</strong> Satıcının tipi (Sahibinden – bireysel, Galeri – bayi, Yetkili bayi, vs.).</p></li>
<li><p><strong>MTV (VehicleTax(TRY)):</strong> Aracın yıllık Motorlu Taşıtlar Vergisi tutarı (TL).</p></li>
<li><p><strong>Hasar/Tramer Geçmişi (AccidentHistory):</strong> Aracın kaza ve hasar kaydı bilgisi (Tramer kayıtları; örn. “Hasar kaydı yok” veya belli bir tutar).</p>
<p>Veri setindeki sütun isimleri orijinal ilandan elde edildiği şekildedir. Ancak analizlerde kolaylık olması açısından, <code>Price_Clean</code>, <code>Year_Clean</code> gibi temizlenmiş sayısal alanlar kullanılmıştır. Bu temizlenmiş değişkenler, ilgili metin alanlarından sayısal değerlerin çıkarılmasıyla oluşturulmuştur. Örneğin <strong>Fiyat (Price)</strong> alanındaki “1.200.000 TL” değeri <code>Price_Clean</code> sütununda <strong>1200000</strong> şeklinde yer almaktadır. Benzer şekilde <strong>Motor Hacmi</strong> ve <strong>Motor Gücü</strong> metin karşılıklarından sayılar (cc ve HP) ayıklanarak <code>EngineSize_Clean</code> ve <code>EnginePower_Clean</code> oluşturulmuştur.</p></li>
</ul>
<p><strong>Eksik Değerler ve Ön İşleme:</strong> Veride bazı eksik değerler sınırlı düzeydedir. Örneğin, <code>EngineSize_Clean</code> değişkeninde 191 kayıtta, <code>EnginePower_Clean</code> değişkeninde 198 kayıtta eksik bulunmuştur (toplam 6675 gözlemin yaklaşık %3’ü). Fiyat ve kilometre bilgileri ise tüm kayıtlarda mevcuttur. Eksik motor özelliklerine sahip kayıtlar analizlerin ilgili kısımlarında ihmal edilmiş veya gerektiğinde doldurulmuştur. Bunun dışında, uç değer tespitinde <strong>38.500.000 TL</strong> gibi aşırı yüksek fiyatlı bir ilan saptanmıştır (muhtemelen lüks bir araç). Bu tür uç değerler dağılım görselleştirmelerinde grafik okunabilirliğini sağlamak adına ayıklanmıştır. Aykırı değerlerin modele etkisi ayrıca değerlendirilmiştir.</p>
<p>1.Veri Seti: İkinci el araç ilan verisi (Cars.csv)</p>
<p>2.Coğrafi Veri: Türkiye illeri shapefile (tr.shp)</p>
<p><strong>Veri Kaynağı</strong></p>
<ul>
<li></li>
<li><p><a href="https://www.kaggle.com/datasets/bahridgr/used-car-prices-in-trkiye-2025-entr" class="uri">https://www.kaggle.com/datasets/bahridgr/used-car-prices-in-trkiye-2025-entr</a></p></li>
<li></li>
</ul>
<p><strong>Veri Hakkında Genel Bilgiler</strong></p>
<p>-Toplam: 6675 satır, 23 sütun</p>
<p>-Temel sütunlar: city, brand, model, price, mileage, engine_power, fuel_type, transmission_type, body_type, accident_history</p>
<p>-Veride eksik gözlemler bulunmakta olup analiz öncesinde ön işlemden geçirilmiştir.</p>
<p><strong>Tercih Sebebi</strong></p>
<p>R U OK ekibi olarak proje konumuzun Cars Veri Seti olarak seçilmesinin temel nedeni, Cars Veri Seti’nin Türkiye otomotiv pazarına ait gerçek-dünya verileri içeren zengin bir veri seti üzerine kurulması ve bu sayede yapacağımız araştırma sonuçlarının doğrudan sahaya uyarlanabilir olmasına imkan sağlamasıdır. trıca bu veri seti, yerel satış dinamiklerini yansıtan ayrıntılı sayısal ve kategorik değişkenler, pazar eğilimleri, tüketici tercihleri ve rekabet stratejileri hakkında derinlemesine, eyleme dönük içgörüler üretmeye imkân tanımaktadır. Bu veri setinin hacmi ve niteliği, regresyon, makine öğrenimi ile zaman serisi modellemeleri gibi yöntemlerle güvenilir fiyat tahminleri yapılmasını mümkün kılmaktadır; çok boyutlu değişken yapısı ise tanımlayıcı istatistikten kümeleme ve segmentasyona kadar geniş bir analitik yelpazenin uygulanmasına olanak vermektedir.</p>
<p><strong>Veri Ön İşleme</strong></p>
<p><strong>Kütüphanelerin Yüklenmesi</strong></p>
<p>{r output=FALSE} library(tidyverse) # dplyr, ggplot2, readr, tidyr, stringr, purrr, forcats library(janitor) # Sütun isimlerini temizleme library(naniar) # Eksik değer görselleştirme library(scales) # Etiket biçimlendirme (label_number vs.) library(lubridate) # Tarih işleme library(caret) # Modelleme ve veri bölme library(randomForest) # Rastgele orman modeli library(vip) # Değişken önem grafikleri library(sf) # Shapefile okuma ve coğrafi veri library(leaflet) # İnteraktif harita library(TRmaps) # Türkiye il haritası library(stringi) # Türkçe karakter dönüştürme için</p>
<p><strong>Veri Okuma ve Temizlik</strong></p>
<p>{r message=FALSE, warning=FALSE } # Veriyi oku cars &lt;- read_csv(“csv/Cars.csv”) %&gt;% clean_names() # Tüm karakter sütunlarında \n, \r, \t, _x000D_ gibi ifadeleri temizle clean_text_columns &lt;- function(df) { df %&gt;% mutate(across(where(is.character), ~ gsub(“\\n|\\r|\\t|_x000D_”, ” “, .))) %&gt;% mutate(across(where(is.character), ~ str_trim(.))) } # Temizleme fonksiyonunu uygula cars &lt;- clean_text_columns(cars) # Silinecek sütunlar drop_list &lt;- c(”listing_title”, “listing_id”) # Sütunları çıkar ve tekrarlayan satırları sil cars &lt;- cars %&gt;% select(-all_of(drop_list)) %&gt;% distinct() # Araç yaşı hesapla cars &lt;- cars %&gt;% mutate( year_clean = as.numeric(year), age = 2025 - year_clean ) # car_data’nın ilk 10 satırını tablo olarak bastır knitr::kable(head(cars, 10), caption = “Hazırlanan Veri Setinin İlk 10 Satırı”)</p>
<p><strong>Eksik Verilerin Doldurulması</strong></p>
<p>{r output=FALSE} # Mod hesaplama fonksiyonu mode_impute &lt;- function(x) { ux &lt;- na.omit(x) ux[which.max(tabulate(match(x, ux)))] } # Sayısal sütunları medyanla doldur cars &lt;- cars %&gt;% mutate( mileage_clean = ifelse(is.na(mileage_clean), median(mileage_clean, na.rm = TRUE), mileage_clean), engine_power_clean = ifelse(is.na(engine_power_clean), median(engine_power_clean, na.rm = TRUE), engine_power_clean), year_clean = ifelse(is.na(year_clean), median(year_clean, na.rm = TRUE), year_clean) ) # Kategorik sütunları mod ile doldur categorical_cols &lt;- c(“fuel_type”, “transmission_type”, “seller_type”, “accident_history”, “color”, “drive_train”, “body_type”) for (col in categorical_cols) { cars[[col]][is.na(cars[[col]])] &lt;- mode_impute(cars[[col]]) } # Sayıları karakter içinden ayıkla ve sayıya çevir cars &lt;- cars %&gt;% mutate( engine_power_hp = str_extract(engine_power_hp, “\\d+”) %&gt;% as.numeric(), engine_size_clean = str_extract(engine_size_clean, “\\d+”) %&gt;% as.numeric(), engine_size_cc = parse_number(as.character(engine_size_cc)) ) # engine_power_hp ve engine_size sütunlarını marka-model bazlı doldur cars &lt;- cars %&gt;% group_by(brand, model) %&gt;% mutate( engine_power_hp = ifelse(is.na(engine_power_hp), round(mean(engine_power_hp, na.rm = TRUE)), engine_power_hp), engine_size_clean = ifelse(is.na(engine_size_clean), round(mean(engine_size_clean, na.rm = TRUE)), engine_size_clean), engine_size_cc = ifelse(is.na(engine_size_cc), round(mean(engine_size_cc, na.rm = TRUE)), engine_size_cc) ) %&gt;% ungroup() # Kalan NA’lar için genel medyanla doldurma cars &lt;- cars %&gt;% mutate( engine_power_hp = ifelse(is.na(engine_power_hp), median(engine_power_hp, na.rm = TRUE), engine_power_hp), engine_size_clean = ifelse(is.na(engine_size_clean), median(engine_size_clean, na.rm = TRUE), engine_size_clean), engine_size_cc = ifelse(is.na(engine_size_cc), median(engine_size_cc, na.rm = TRUE), engine_size_cc) ) # Eksik year varsa marka-model ortalaması ile doldur cars &lt;- cars %&gt;% group_by(brand, model) %&gt;% mutate(year = ifelse(is.na(year), round(mean(year, na.rm = TRUE)), year)) %&gt;% ungroup() # Araç yaşını yeniden güncelle cars &lt;- cars %&gt;% mutate(age = 2025 - year) # Kullanılmayan sütunları kaldır cars &lt;- cars %&gt;% select(-any_of(c(“vehicle_tax_try”, “trade_in_available”))) # Kritik alanlarda eksik varsa o satırları sil cars &lt;- cars %&gt;% filter(!is.na(year), !is.na(model), !is.na(age)) # Eksik değerleri görselleştir gg_miss_var(cars)</p>
<p>{r output=FALSE} cars %&gt;% summarise(across(everything(), ~ sum(is.na(.)))) %&gt;% pivot_longer(cols = everything(), names_to = “değişken”, values_to = “eksik_sayı”) %&gt;% filter(eksik_sayı &gt; 0) %&gt;% arrange(desc(eksik_sayı))</p>
<p><strong>Analiz</strong></p>
<p><strong>Keşifsel Veri Analizi</strong></p>
<p>{r } cars %&gt;% summarise( mean_price = mean(price_clean, na.rm = TRUE), mean_km = mean(mileage_clean, na.rm = TRUE), mean_hp = mean(engine_power_clean, na.rm = TRUE) )</p>
<p>Bu da demektir ki veri setindeki ikinci el araçların ortalama:</p>
<p>Fiyatı yaklaşık 787.000 TL</p>
<p>Kilometresi 217.000 km</p>
<p>Motor gücü 108 HP</p>
<p><strong>Marka Bazlı Ortalama Fiyat Dağılımı</strong></p>
<p>{r, message=FALSE, warning=FALSE} # Marka bazlı ortalama fiyat ve ilan sayısı brand_summary &lt;- cars %&gt;% group_by(brand) %&gt;% summarise( mean_price = mean(price_clean, na.rm = TRUE), count = n() ) %&gt;% filter(count &gt; 30) %&gt;% # Çok az gözleme sahip markaları filtrele (isteğe bağlı) arrange(desc(mean_price)) # Görselleştirme ggplot(brand_summary, aes(x = reorder(brand, mean_price), y = mean_price)) + geom_col(fill = “darkblue”) + coord_flip() + scale_y_continuous(labels = label_number(suffix = ” TL”, big.mark = “.”, decimal.mark = “,”)) + labs( title = “Markalara Göre Ortalama Araç Fiyatları”, x = “Marka”, y = “Ortalama Fiyat (TL)” ) + theme_minimal(base_size = 14)</p>
<p>Markalara Göre Ortalama Araç Fiyatları</p>
<p>Mercedes-Benz, açık ara farkla en yüksek ortalama ikinci el araç fiyatına sahip markadır. Bu, markanın genellikle lüks segmentte konumlanmasından ve daha yeni modellerin piyasada yoğun olmasından kaynaklanıyor olabilir.</p>
<p>Onu Audi ve BMW takip etmektedir. Bu üç marka, genellikle premium algısı olan ve fiyat aralığı yüksek modeller sunan üreticilerdir.</p>
<p>Honda, Volkswagen ve Toyota gibi markalar orta segmentte konumlanırken; Fiat, Renault, Opel gibi markalar ise genellikle daha erişilebilir fiyatlara sahip modelleriyle öne çıkmaktadır.</p>
<p>Listenin alt sıralarında yer alan markalar, daha uygun fiyatlı ve/veya daha eski model araçlara sahip olabilirler.</p>
<p><strong>Vites Tipine Göre Fiyat</strong></p>
<p>{r, message=FALSE, warning= FALSE } cars %&gt;% filter(!is.na(transmission_type), !is.na(price_clean), price_clean &gt; 0) %&gt;% ggplot(aes(x = transmission_type, y = log10(price_clean))) + geom_boxplot(fill = “lightgreen”, outlier.color = “darkred”, outlier.size = 1.2) + labs( title = “Vites Tipine Göre Log10(Fiyat) Dağılımı”, x = “Vites Tipi”, y = “log10(Fiyat) (TL)” ) + theme_minimal()</p>
<p>Vites Tipine Göre Fiyat Dağılımı Automatic Medyan (orta çizgi) log10(fiyat) değeri en yüksek olan grup.</p>
<p>Fiyat dağılımı geniş ve üst uçta birçok lüks fiyatlı araç (outlier) mevcut.</p>
<p>Bu, otomatik vitesli araçların genelde daha pahalı olduğunu ve aralarında lüks segmentlerin de bulunduğunu gösterir.</p>
<p>Manual Medyan fiyatı en düşük olan grup.</p>
<p>Dağılım daha dar ve genellikle düşük fiyatlı araçlar bu grupta yer alıyor.</p>
<p>Daha az lüks model içeren ekonomik seçeneklerin bu grupta yoğunlaştığı anlaşılıyor.</p>
<p>Semi-Automatic Medyan değeri, otomatikten düşük ama manuele göre daha yüksek.</p>
<p>Yayılım dar, yani fiyatlar bu grupta daha homojen.</p>
<p>Genellikle orta segmentte yer alan araçlar bu grupta olabilir.</p>
<p>{r, message=FALSE, warning=FALSE} # Önce city_stats oluştur city_stats &lt;- cars %&gt;% filter(!is.na(city), !is.na(price_clean)) %&gt;% group_by(city) %&gt;% summarise( mean_price = mean(price_clean, na.rm = TRUE), count = n() ) # Bar chart city_stats %&gt;% filter(count &gt;= 30) %&gt;% ggplot(aes(x = fct_reorder(city, mean_price), y = mean_price)) + geom_col(fill = “darkcyan”, width = 0.7) + coord_flip() + scale_y_continuous( labels = label_number(suffix = ” TL”, big.mark = “.”, decimal.mark = “,”), expand = expansion(mult = c(0, 0.1)) ) + labs( title = “Ortalama Fiyatı En Yüksek Şehirler (Min. 30 İlan)”, x = “Şehir”, y = “Ortalama Fiyat” ) + theme_minimal(base_size = 10)</p>
<p>{r, message=FALSE, warning=FALSE} # Ortalama ve Medyan Fiyatları Hazırla fiyat_ozet &lt;- cars %&gt;% filter(!is.na(city), !is.na(price_clean)) %&gt;% group_by(city) %&gt;% filter(n() &gt;= 30) %&gt;% summarise( Ortalama = mean(price_clean, na.rm = TRUE), Medyan = median(price_clean, na.rm = TRUE) ) %&gt;% pivot_longer(cols = c(“Ortalama”, “Medyan”), names_to = “FiyatTürü”, values_to = “Fiyat”) %&gt;% mutate(city = fct_reorder(city, Fiyat)) # Facet Wrap ile Görselleştir ggplot(fiyat_ozet, aes(x = city, y = Fiyat)) + geom_col(fill = “darkcyan”) + coord_flip() + facet_wrap(~ FiyatTürü, scales = “free_x”) + scale_y_continuous(labels = label_number(suffix = ” TL”, big.mark = “.”, decimal.mark = “,”)) + labs( title = “Şehir Bazlı Ortalama ve Medyan Fiyat Karşılaştırması”, x = “Şehir”, y = “Fiyat” ) + theme_minimal(base_size = 9)</p>
<p>Ortalama Fiyat Paneli (Sağ) Uç değerler hesaba katıldığı için bazı şehirlerde fiyatlar yüksek çıkmaktadır.</p>
<p>Örneğin: İstanbul, Muğla gibi şehirlerde bazı çok pahalı araçlar ortalamayı yukarı çekmiş.</p>
<p>Medyan Fiyat Paneli (Sol) Medyan, fiyatların tam ortasında yer alan değerdir ve uç fiyatlardan etkilenmez.</p>
<p>İstanbul yine en üstte olsa da, bazı şehirlerde medyan fiyatın ortalamadan çok daha düşük olduğu gözlemleniyor → bu da ilanlarda çok pahalı araçlar olduğunu gösterir (muhtemelen lüks ilanlar etkiliyor).</p>
<p>Uç değerlerin fiyat analizini nasıl etkilediğini görebiliyoruz.</p>
<p>Muğla, Antalya, Batman gibi şehirlerde ortalama → medyandan çok büyük, yani lüks ilanlar fiyatları şişiriyor.</p>
<p>Daha homojen pazarlarda (örneğin Adıyaman, Tokat) ortalama ve medyan birbirine daha yakın.</p>
<p>{r, message=FALSE, warning=FALSE} cars %&gt;% group_by(fuel_type) %&gt;% summarise(mean_price = mean(price_clean, na.rm = TRUE)) %&gt;% ggplot(aes(x = reorder(fuel_type, mean_price), y = mean_price)) + geom_col(fill = “darkgreen”) + coord_flip() + scale_y_continuous(labels = scales::label_number(suffix = ” TL”, big.mark = “.”, decimal.mark = “,”)) + labs( title = “Yakıt Tipine Göre Ortalama Araç Fiyatları”, x = “Yakıt Türü”, y = “Ortalama Fiyat (TL)” ) + theme_minimal(base_size = 13)</p>
<p>Bu grafikte, Türkiye’deki ikinci el araç pazarında kullanılan yakıt türlerinin ortalama araç fiyatlarına etkisi incelenmektedir.</p>
<p>Benzinli Araçlar En yaygın yakıt türlerinden biridir.</p>
<p>Ortalama fiyatı genellikle orta seviyede kalmaktadır.</p>
<p>Geniş fiyat aralığına sahip, hem ekonomik hem de premium modellerde tercih edilmektedir.</p>
<p>Elektrikli Araçlar Ortalama fiyatı en yüksek olan gruptur.</p>
<p>Bunun nedeni, Türkiye’de elektrikli araçların henüz yaygın olmaması ve çoğunun yeni teknolojiye sahip pahalı modeller olmasıdır.</p>
<p>Dizel Araçlar Ortalama fiyatları benzinli araçlara benzer seviyededir ya da biraz daha yüksektir.</p>
<p>Özellikle yüksek kilometreli araçlarda tercih edilse de, motor ömrü uzun olduğu için fiyatları belirli bir seviyede korunmaktadır.</p>
<p>Hibrit (Hybrid) Elektrik-benzin kombinasyonuna sahip bu araçlar genelde yeni teknolojiye sahip oldukları için ortalama fiyatları da yüksek çıkmaktadır.</p>
<p>Yakıt tasarrufu ve çevreci özellikleri fiyatlarına yansımaktadır. X ## Trend Analizi</p>
<p><strong>Araç Yaşı ile Fiyat İlişkisi</strong></p>
<p>{r,message= FALSE, warning= FALSE } # Outlier’ları filtrele (örnek: 1. ve 99. persentil arası tut) q_low &lt;- quantile(cars$mileage_clean, 0.01, na.rm = TRUE) q_high &lt;- quantile(cars$mileage_clean, 0.99, na.rm = TRUE) cars_filtered &lt;- cars %&gt;% filter( mileage_clean &gt;= q_low, mileage_clean &lt;= q_high, price_clean &lt;= quantile(price_clean, 0.99, na.rm = TRUE) ) # Grafik ggplot(data = cars_filtered, aes(x = mileage_clean, y = price_clean)) + geom_point(color = “mediumorchid”, alpha = 0.4) + geom_smooth(method = “lm”, se = FALSE, color = “black”, linewidth = 1.1) + labs( title = “Kilometre ile Fiyat Arasındaki İlişki (Outlier’sız)”, x = “Kilometre”, y = “Fiyat (TL)” ) + scale_y_continuous(labels = label_number(big.mark = “.”, decimal.mark = “,”, suffix = ” TL”)) + scale_x_continuous(labels = label_number(big.mark = “.”, decimal.mark = “,”, suffix = ” km”)) invisible(theme_minimal())</p>
<p>Negatif Korelasyon (Eğim Azalan):</p>
<p>Siyah çizgi (regresyon doğrusu), kilometre arttıkça araç fiyatının azaldığını gösteriyor.</p>
<p>Bu beklenen bir sonuç: Daha fazla kullanılmış (yüksek km’li) araçlar genellikle daha ucuz.</p>
<p>Veri Dağılımı:</p>
<p>0–50.000 km arası araçlar daha yüksek fiyatlara sahip. Fiyat 3.000.000 TL’ye kadar çıkabiliyor.</p>
<p>150.000 km’den sonra fiyatlar genellikle 1.000.000 TL’nin altına düşüyor.</p>
<p>Yoğunluk:</p>
<p>En yoğun noktalar (mor kümeler) 50.000 – 150.000 km arası ve 500.000 – 1.500.000 TL fiyat aralığında toplanıyor.</p>
<p>Bu da piyasadaki en yaygın ikinci el araç kitlesini gösteriyor.</p>
<p>Aykırı Değerlerin Etkisi Azalmış:</p>
<p>İlk grafiğe göre çok uç fiyatlar (&gt;30.000.000 TL gibi) çıkarıldığı için regresyon çizgisi daha gerçekçi bir eğilim gösteriyor.</p>
<p>Kilometre arttıkça araç fiyatı genellikle düşmektedir. Özellikle 150.000 km üzerindeki araçlar belirgin şekilde daha ucuzdur. Ancak düşük kilometreli araçların fiyatları çok değişken olup bazı modellerde yüksek fiyatlara ulaşabilmektedir.</p>
<p><strong>Araç Yaşı ve Ortalama Fiyat</strong></p>
<p>{r, message=FALSE, warning=FALSE } cars %&gt;% group_by(age) %&gt;% summarise(mean_price = mean(price_clean, na.rm = TRUE)) %&gt;% ggplot(aes(x = age, y = mean_price)) + geom_line(color = “red”, size = 1.2) + geom_point(color = “black”) + scale_x_continuous(breaks = pretty_breaks()) + scale_y_continuous(labels = label_number(suffix = ” Tl”, big.mark = “.”, decimal.mark = “,”)) + labs( title = “Araç Yaşına Göre Ortalama Fiyat”, x = “Araç Yaşı”, y = “Ortalama Fiyat” ) + theme_minimal()</p>
<p>Genel Eğilim (Azalan Trend):</p>
<p>Grafik kırmızı bir çizgiyle, araç yaşı arttıkça ortalama fiyatın düştüğünü net şekilde gösteriyor.</p>
<p>Özellikle 0–5 yaş arası araçlarda fiyatlar oldukça yüksek. Bu yaş aralığında araçlar en yeni ve en pahalı olanlar.</p>
<p>Fiyat Düşüş Hızı:</p>
<p>İlk 3–4 yıl içinde fiyatlar daha hızlı düşerken, 7 yaşından sonra düşüş hızı yavaşlıyor ve daha durağan hale geliyor.</p>
<p>Bu, ikinci el piyasasında ilk yıllarda değer kaybının daha yüksek olduğunu gösteriyor (araba değer kaybı eğrisi).</p>
<p>{r, message=FALSE, warning=FALSE} # Türkiye shapefile’ını oku turkiye_il &lt;- st_read(“csv/tr_shp/tr.shp”, quiet = TRUE) # Türkçe karakterleri düzleştiren yardımcı fonksiyon normalize_city &lt;- function(x) { x %&gt;% stri_trans_general(“Latin-ASCII”) %&gt;% # Türkçe karakterleri dönüştür (İ→I, Ş→S, Ü→U) toupper() %&gt;% trimws() } # Ortalama fiyatları hesapla (ilan sayısı 30’dan büyük olanlar) fiyatlar &lt;- cars %&gt;% filter(!is.na(city), !is.na(price_clean)) %&gt;% group_by(city) %&gt;% summarise( mean_price = mean(price_clean, na.rm = TRUE), ilan_sayisi = n() ) %&gt;% filter(ilan_sayisi &gt;= 30) %&gt;% mutate(city_clean = normalize_city(city)) # Harita verisini temizle turkiye_il &lt;- turkiye_il %&gt;% mutate(city_clean = normalize_city(name)) # name yerine IL_ADI kullanıyorsan onu yaz # Join işlemi turkiye_il &lt;- turkiye_il %&gt;% left_join(fiyatlar, by = “city_clean”) # Harita paleti pal &lt;- colorNumeric(palette = “YlOrRd”, domain = turkiye_il$mean_price, na.color = “gray90”) # Harita çizimi leaflet(data = turkiye_il) %&gt;% addTiles() %&gt;% addPolygons( fillColor = ~pal(mean_price), weight = 1, opacity = 1, color = “white”, dashArray = “3”, fillOpacity = 0.7, label = ~paste0(name, “: ₺”, format(round(mean_price), big.mark = “.”, decimal.mark = “,”)), highlightOptions = highlightOptions( weight = 3, color = “#666”, fillOpacity = 0.9, bringToFront = TRUE ) ) %&gt;% addLegend(pal = pal, values = ~mean_price, opacity = 0.7, title = “Ortalama Fiyat (₺)”, position = “bottomright”)</p>
<p><strong>Model Uydurma</strong></p>
<p><strong>Modelin Performansı</strong></p>
<p><strong>Model için Veri Setinin Hazırlanması</strong></p>
<p>{r} # Temizlenmiş veri üzerinden model veri seti oluşturuluyor car_data &lt;- cars %&gt;% filter( !is.na(price_clean), !is.na(year_clean), !is.na(mileage_clean), !is.na(engine_power_clean), !is.na(fuel_type), !is.na(transmission_type), !is.na(brand), !is.na(body_type) ) %&gt;% mutate( price_log = log10(price_clean), # log dönüşümü ile daha iyi dağılım across(c(fuel_type, transmission_type, brand, body_type), as.factor) ) %&gt;% select(price_log, year_clean, mileage_clean, engine_power_clean, fuel_type, transmission_type, brand, body_type) # car_data’nın ilk 10 satırını tablo olarak bastır knitr::kable(head(car_data, 10), caption = “Modelleme için Hazırlanan Veri Setinin İlk 10 Satırı”)</p>
<p><strong>Modelin Eğitilmesi ve Test Edilmesi</strong></p>
<p>{r message=FALSE, warning=FALSE} set.seed(123) split &lt;- createDataPartition(car_data$price_log, p = 0.8, list = FALSE) train_set &lt;- car_data[split, ] test_set &lt;- car_data[-split, ] rf_model &lt;- randomForest( price_log ~ ., data = train_set, ntree = 100, importance = TRUE ) # Tahmin yap predicted &lt;- predict(rf_model, newdata = test_set) actual &lt;- test_set$price_log # Performans metrikleri (log10 dönüşümlü) rmse &lt;- sqrt(mean((predicted - actual)^2)) mae &lt;- mean(abs(predicted - actual)) cat(“RMSE (log10):”, round(rmse, 3), “\n”) cat(“MAE (log10):”, round(mae, 3), “\n”) # Gerçek ölçekte hata tahmini (yüzdelik) relative_error &lt;- (10^rmse - 1) * 100 cat(“Tahmini Ortalama Hata (%):”, round(relative_error, 1), “%”)</p>
<p><strong>Tahmin Doğruluğu ve Yorum</strong></p>
<p>-RMSE (log10): 0.071</p>
<p>-MAE (log10): 0.051</p>
<p>-Tahmini Ortalama Hata (%): ~17.8%</p>
<p>Bu sonuçlar, modelin ikinci el araç fiyatlarını oldukça başarılı şekilde tahmin ettiğini göstermektedir. Özellikle ikinci el araç piyasasındaki dalgalanma, marka ve model çeşitliliği göz önüne alındığında, bu hata oranı güçlü bir performansa işaret eder.</p>
<p>Model, fiyatların %80’inden fazlasını gerçek değerin ±%18’lik bir aralığında öngörebilmiştir.</p>
<p><strong>Önemli Değişkenler</strong></p>
<p>{r } vip(rf_model, num_features = 10)</p>
<p><strong>Gerçek Fiyat ile Tahmin Edilen Fiyat Karşılaştırması</strong></p>
<p>{r } # Test veri seti üzerinde tahmin yap ve hata metriklerini hesapla tahmin_df &lt;- test_set %&gt;% mutate( tahmin_log = predict(rf_model, newdata = .), # Log10 tahmini tahmin_fiyat = 10^tahmin_log, # Gerçek ölçekli tahmin gercek_fiyat = 10^price_log, # Gerçek fiyat (log’dan çıkarıldı) hata = abs(tahmin_fiyat - gercek_fiyat), # Mutlak hata hata_orani = round((hata / gercek_fiyat) * 100, 1) # Yüzde hata ) %&gt;% select(brand, year_clean, mileage_clean, engine_power_clean, fuel_type, transmission_type, body_type, gercek_fiyat, tahmin_fiyat, hata, hata_orani) # En başarılı tahmin edilen 10 örneği görüntüle knitr::kable(head(tahmin_df %&gt;% arrange(hata_orani), 10), caption = “En Düşük Hatalı 10 Fiyat Tahmini”)</p>
<p><strong>Sonuçlar</strong></p>
<p><strong>Sonuçlar ve Ana Çıkarımlar</strong></p>
<p>-İkinci el araç pazarında en yüksek ortalama fiyatlara sahip şehirler İstanbul, Muğla ve İzmir olarak öne çıkmaktadır. Bu şehirlerdeki ilanlarda lüks segment araçların yoğunluğu fiyatları yukarı çekmektedir.</p>
<p>-Otomatik vitesli araçların fiyatları, manuel ve yarı otomatik araçlara kıyasla belirgin şekilde daha yüksektir. Bu durum, otomatik araçlara olan talebin ve sundukları konforun fiyatlara yansımasını göstermektedir.</p>
<p>-Araç yaşı ile fiyat arasında negatif bir ilişki gözlemlenmiştir. Özellikle ilk 5 yıl içerisinde araçlar önemli bir değer kaybı yaşamaktadır. Bu da ikinci el pazarda araçların ilk yıllarındaki amortisman etkisini doğrulamaktadır.</p>
<p>-150.000 km üzeri kilometreye sahip araçlarda, fiyatların ortalamaya göre ciddi ölçüde düştüğü görülmektedir. Yüksek kilometre, alıcı açısından risk olarak değerlendirildiği için bu düşüş beklenen bir durumdur.</p>
<p>-Random Forest modeli ile oluşturulan fiyat tahmin modeli, log10 dönüşümlü fiyatlar üzerinde %80’in üzerinde doğruluk sağlamıştır. Bu da modelin güçlü bir öngörü kabiliyeti sunduğunu göstermektedir.</p>
<p>-Ortalama ve medyan fiyat karşılaştırmaları, ilanlardaki uç değerlerin bazı şehirlerde fiyat analizini nasıl etkilediğini net şekilde ortaya koymuştur. Medyan analizinin kullanımı, ortalamaların yanıltıcı olabileceği durumlarda daha gerçekçi içgörüler sağlamaktadır.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>EMU Hacettepe MUY665 - 2025-2026 Bahar</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>